<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- web page title  -->
    <title>React Hooks useCallback()</title>
    <!-- link style sheet CSS  -->
    <link rel="stylesheet" href="Assest/styleFile/style.css">
    <!-- link page favicon -->
    <link rel="shortcut icon" href="Assest/images/favicon.png" type="image/x-icon">
</head>

<body>
    <!-- main conatainer  -->
    <div class="container">

        <!-- ReactJS logo  -->
        <div id="img">
            <img src="Assest/images/react.js-logo.png" class="img-logo" alt="logo-reactJS">
        </div>

        <!-- container items  -->
        <div class="container-items">
            <!-- Notes heading -->
            <h2>useCallback() | React</h2>
            <h3>useCallback()</h3>
            <p>In react, <b>functions are recreated</b> on each render.</p>
            <p>When you define a function inside a functional component, it gets <b>recreated every time</b> the componentn re-renders, even if the function body is the same.</p>
            <p>This can Lead to <b>unnecessary re-rendering of child components</b> that depend on these functions.</p>
            <p>Here's where <b>useCallback</b> comes into play.</p>
            <p>it allow you to <b>memoize a function</b>  so that it's only created once and <b>reused</b> across renders, as long as its <b>dependencies</b> (specified in the second argument) remain the some.</p>

                        <!-- Example -->
            <div class="Example">
                <h3>// syntax</h3>
                <div class="Example-code">
                    <div class="Example-code-syntex">
                        const memoizedCB = useCallback(callback, depend);
                    </div>
                </div>
            </div>

            <ul>
                <li><b>callback:</b> The Function that you want to memoize.</li>
                <li><b>dependencies:</b> An array of dependencies. if any of these dependencies change, the memoized callback will be recreated.</li>
            </ul>

            <!-- Example -->
            <div class="Example">
                <h3>useCallback() | Example</h3>
                <div class="Example-code">
                    <div class="Example-Number">
                        1
                        2
                        3
                        4
                        5
                        6
                        7
                        8
                        9
                        10
                        11
                        12
                        13
                        14
                        15
                        16
                        17
                        18
                        19
                        20
                        21
                        22
                        23
                        24
                        25
                        26
                        27
                        28
                        29
                        30
                        31
                        32
                        33
                        34
                        35
                    </div>
                    <div class="Example-code-syntex">
                            import React, { useState, useCallback } from "react";<br>
                            <br>
                            function ParentComponent() { <br>
                                    const [count , setCount] = useState(0);<br>
                                    <br>
                                    // without useCallback: <br>
                                    // A new increment function is created on every render <br>
                                    <br>
                                    const increment = ( )=> {<br>
                                        setCount( count + 1); <br>
                                    };<br>
                                
                                <br>
                                // without useCallback:<br>
                                // The function in only re-created on every when count changes  <br>
    <br>
                                const memoizedIncrement = useCallback (() => { <br>
                                    setCount((preCount => preCount + 1)); <br>
                                } [count]); <br>

                                return ( <br>
                                    &lt;div&gt;  <br>
                                        &lt;p&gt;Count : {count}&lt;/p&gt;  <br>
                                        {/* Receives the increment function */}  <br>
                                        &lt;ChildComponent increment = {increment} /&gt;  <br>
 <br>
                                        {/* Receives the memoizedIncrement function */}  <br>
                                        &lt;ChildComponent increment = {memoizedIncrement} /&gt;  <br>
                                    &lt;/div&gt;  <br>
                                ) <br>
                            }; <br>
 <br>
                            function ChildComponent ({increment}){ <br>
                                return &lt;button onclick={increment}&gt;Increment&lt;/button&gt;; <br>
                            } <br>
 <br>
                            export default ParentComponent;
                    </div>
                </div>
            </div>

            <h3>In The Example</h3>

            <p>without using useCallback, the increment function would be <b>recreated on every render</b> of the ParentComponent. leading to potential performanse issues.</p>

            <p>However, by using useCallback the memoizedIncrement function is <b>only recreated</b> when the count state changes which  <b>optimizes performanse</b> by preventing unnecessary re-renders of the ChildComponent.
             </p>

            <h3>Remember:</h3>
            <p>Remember that while useCallbackcan help improve performanse in certion situation , it's important to <b>avoid everusing it</b>.</p>

            <p>only apply it ti function that actually couse performanse issues due to frequent re-creation in most cases, REAC'S built-in reconciliation process handles function re-creation efficiently</p>

        </div>
    </div>
</body>

</html>